/*
 * 面向对象特征之三：多态性
 * 
 * 1.理解多态性：可以理解为一个事物的多种形态。
 * 2.何为多态性：
 *   对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）
 *   
 * 3. 多态的使用：虚拟方法调用
 *   有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。
 *   总结：编译，看左边；运行，看右边。
 *  
 *   Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边。
 *        >若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)
 *        >多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法）
 *                     “看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）
 *
 *    对象的多态———在Java中,子类的对象可以替代父类的对象使用
 *        >一个变量只能有一种确定的数据类型
 *        >一个引用类型变量可能指向(引用)多种不同类型的对象
 *
 *    子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。
 *
 *     一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法
 *
 * 4.多态性的使用前提：  ① 类的继承关系  ② 方法的重写
 * 
 * 5.多态的作用：提高了代码的通用性，常称作接口重用
 *
 * 6.对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）
 *
 * 7.虚拟方法调用(Virtual Method Invocation)
 *    (1)虚拟方法调用(多态情况下)
 *        子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
 *    
 *     Person e = new Student();
 *     e.getInfo(); //调用Student类的getInfo()方法
 *    (2)编译时类型和运行时类型
 *        编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。——动态绑定
 */
public class PersonTest {
	
	
	public static void main(String[] args) {
		
		Person p1 = new Person();
		p1.eat();
		
		Man man = new Man();
		man.eat();
		man.age = 25;
		man.earnMoney();
		
		//*************************************************
		System.out.println("*******************");
		//对象的多态性：父类的引用指向子类的对象
		Person p2 = new Man();
//		Person p3 = new Woman();
		//多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法 ---虚拟方法调用
		p2.eat();
		p2.walk();
		
//		p2.earnMoney();
		
		System.out.println(p2.id);//1001
		
	}
}
